#!/usr/bin/env node

const package = require('../package.json')
const program = require('commander');
const fs = require('fs')
const path = require('path')

const NodeDeploy = require('../lib/deploy/node').default
const NodeZipBuilder = require('../lib/builder/node-zip').default
const NodeZipUploader = require('../lib/uploader/node-zip').default
const NodeController = require('../lib/controller/node').default

const FunctionBuilder = require('../lib/builder/function').default
const FunctionDeploy = require('../lib/deploy/function').default

const WebsocketDeploy = require('../lib/deploy/websocket').default
const WebsocketBuilder = require('../lib/builder/websocket').default

const readline = require('readline')
const tencentcloud = require('tencentcloud-sdk-nodejs')
const ini = require('ini')

const TCBRC = path.resolve(require('os').homedir(), '.tcbrc.json')

program
  .version(package.version)
  .command('deploy [name]')
  .description('执行完整的发布')
  .option('--start', '发布后启动')
  .action(async function (name, options) {
    const { deploys, common } = getDeploys(name)
    for (let i = 0; i < deploys.length; i++) {
      const deploy = deploys[i]
      if (deploy.type === 'node') {
        if (!deploy.path) {
          throw new Error('未指定发布目录')
        }
        if (!common.server.host && !deploy.config.host) {
          deploy.config.host = await askForInput('请输入服务器IP：')
        }
        if (!common.server.password && !deploy.config.password) {
          deploy.config.password = await askForInput('请输入服务器密码：')
        }
        await new NodeDeploy({
          ...common.server,
          ...deploy
        }).deploy(options.start)
        continue;
      }
      if (deploy.type === 'function') {
        const { secretId, secretKey } = await getSecret()
        await new FunctionDeploy({
          ...common,
          ...deploy,
          secretId,
          secretKey
        }).deploy()
        continue;
      }
      if (deploy.type === 'websocket') {
        const { secretId, secretKey } = await getSecret()
        await new WebsocketDeploy({
          ...common.server,
          ...deploy,
          secretId,
          secretKey
        }).deploy(options.start)
        continue
      }
      throw new Error(`Unsupported deploy type: "${deploy.type}"`)
    }
  })

program
  .command('login')
  .description('登录腾讯云账号')
  .action(login)

program
  .command('logout')
  .description('登出腾讯云账号')
  .action(logout)

program
  .command('build [name]')
  .description('构建')
  .action(async function (name) {
    const { deploys, common } = getDeploys(name)
    for (let i = 0; i < deploys.length; i++) {
      const deploy = deploys[i]
      if (deploy.type === 'node') {
        await new NodeZipBuilder({
          entry: deploy.entry,
          ...deploy.config
        }).build()
        continue;
      }
      if (deploy.type === 'websocket') {
        const { secretId, secretKey } = await getSecret()
        await new WebsocketBuilder({
          ...common.server,
          ...deploy,
          ...deploy.config,
          secretId,
          secretKey
        }).build()
        continue;
      }
      throw new Error(`Unsupported build type: "${deploy.type}"`)
    }
  })

program
  .command('upload [name]')
  .description('上传')
  .action(async function (name) {
    const { deploys, common } = getDeploys(name)
    for (let i = 0; i < deploys.length; i++) {
      const deploy = deploys[i]
      if (deploy.type === 'node') {
        await new NodeZipUploader({
          ...common.server,
          ...deploy.config,
          entry: deploy.entry,
        }).upload()
        continue;
      }
      throw new Error(`Unsupported upload type: "${deploy.type}"`)
    }
  })

program
  .command('reload [name]')
  .description('热重载')
  .action(async function (name) {
    const { deploys, common } = getDeploys(name)
    for (let i = 0; i < deploys.length; i++) {
      const deploy = deploys[i]
      if (deploy.type === 'node' || deploy.type === 'websocket') {
        await new NodeController({
          ...common.server,
          ...deploy.config,
          entry: deploy.entry,
        }).reload()
      }
    }
  })

program
  .command('start [name]')
  .description('启动')
  .action(async function (name) {
    const { deploys } = getDeploys(name)

    for (let i = 0; i < deploys.length; i++) {
      const deploy = deploys[i]
      if (deploy.type === 'node' || deploy.type === 'websocket') {
        await new NodeController({
          entry: deploy.entry,
          ...deploy.config
        }).start()
      }
    }
  })

program
  .command('show <name>')
  .description('查看状态')
  .action(async function (name) {
    const { deploys: [deploy], common } = getDeploys(name)
    if (deploy.type === 'node' || deploy.type === 'websocket') {
      await new NodeController({
        ...common.server,
        ...deploy.config,
        entry: deploy.entry,
      }).show()
    }
  })

program.parse(process.argv)

function getDeploys(name) {
  const configPath = process.cwd() + '/tcb.json'
  if (!fs.existsSync(configPath)) {
    throw new Error('未找到tcb配置文件')
  }
  const tcbConfig = require(configPath)
  let deploys = tcbConfig.deploys
  checkDeploys(deploys)
  if (name) {
    deploys = deploys.filter(d => d.name === name)
  }
  return {
    common: {
      ...tcbConfig.common,
      server: {
        username: 'root',
        port: 22,
        ...tcbConfig.common.server
      }
    },
    deploys
  }
}

function checkDeploys(deploys) {
  const names = {}
  deploys.forEach(d => {
    if (names[d.name]) {
      throw new Error(`Duplicated depoly name: "${d.name}"`)
    }
    names[d.name] = true
  })
}

function askForInput(question) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      resolve(answer)
      rl.close();
    });
  })
}


async function login() {
  const secretId = await askForInput('请输入腾讯云SecretID：')
  const secretKey = await askForInput('请输入腾讯云SecretKey：')
  try {
    await callCloudApi(secretId, secretKey)
  } catch (e) {
    if (e.code.indexOf('AuthFailure') !== -1) {
      throw new Error('登录失败，请检查密钥是否正确')
    }
    throw new Error(`登录失败：${e.code}`)
  }
  fs.writeFileSync(TCBRC, ini.stringify({ secretId, secretKey }))
  return { secretId, secretKey }
}

async function logout() {
  await fs.unlinkSync(TCBRC)
}

async function getSecret() {
  if (fs.existsSync(TCBRC)) {
    const tcbrc = ini.parse(fs.readFileSync(TCBRC, 'utf-8'))
    if (!tcbrc.secretId || !tcbrc.secretKey) {
      // 缺少信息，重新登录
      return await login()
    }
    return { secretId: tcbrc.secretId, secretKey: tcbrc.secretKey }
  } else {
    // 没有登录过
    return await login()
  }
}

function callCloudApi(secretId, secretKey) {
  const CvmClient = tencentcloud.cvm.v20170312.Client;
  const models = tencentcloud.cvm.v20170312.Models;
  const Credential = tencentcloud.common.Credential;
  let cred = new Credential(secretId, secretKey);
  let client = new CvmClient(cred, "ap-shanghai");
  let req = new models.DescribeZonesRequest();

  return new Promise((resolve, reject) => {
    client.DescribeZones(req, function (err, response) {
      if (err) {
        reject(err)
        return;
      }
      resolve(response)
    });
  })
}